from __future__ import absolute_import
import os
import pandas
from .base import *
from .WhiskersTableHandler import WhiskersTableHandler
from .EdgesHandlers import AllEdgesHandler, EdgeSummaryHandler
from .ColorizedWhiskerEnds import ColorizedWhiskerEndsHandler
from .TacHandler import TacHandler, ClusteredTacHandler
from .ContactsSummaryHandlers import (
    ContactsSummaryHandler, ColorizedContactsSummaryHandler)

# For making colorized video
import numpy as np
import tables
import whiskvid
import MCwatch.behavior
import WhiskiWrap

# For lums
import my.video

class MonitorVideoHandler(CalculationHandler):
    """Handler for a monitor video generated by WhiskiWrap trace.
    
    Unlike other handlers, this data is a side effect of trace, so
    this would be set by another calculation.
    
    load_data is not implemented
    """
    _db_field_path = 'monitor_video'
    _name = 'monitor_video'
    
    # Override because it's not just _name
    @property
    def new_path(self):
        return self.video_session.name + '.mkv'

## Handlers for data that haven't been incorporated into the database yet
# This is useful for existing datasets that aren't in the database
# and also because sometimes it's just not worth modifying the database
# The path is hard-coded in the new_path method of each
class CalculationHandlerWithoutDb(CalculationHandler):
    """Overload for data not in db
    
    """
    @property
    def get_path(self):
        """Assumes self.new_path is the name, checks if it exists, returns

        Raises IOError if the file doesn't exist
        """
        full_filename = os.path.join(self.video_session.session_path,
            self.new_path)
        if not os.path.exists(full_filename):
            raise IOError("file does not exist: %s" % full_filename)
        return full_filename
    
    def set_path(self):
        """Return without doing anything, because this is not in the db.
        
        This is so that inherited methods like save_data work.
        
        Returns: None, rather thatn self.new_path, to indicate that
        nothing was done.
        """
        #~ raise NotImplementedError(
            #~ "set_path not available because this calculation is not in the db")
        
        return

class VideoTrackedWhiskersHandler(CalculationHandlerWithoutDb):
    """Tracked whiskers video. Side effect of trace"""
    _name = 'video_tracked_whiskers'

    # Override because it's not just _name
    @property
    def new_path(self):
        return self.video_session.name + '.tracked_whiskers.mkv'

class ColorizationKeystoneInfoHandler(CalculationHandlerWithoutDb):
    """Information about keystone frame
    
    This is a DataFrame, indexed like the whiskers table, with columns
    "frame" (all the same value) and "object" (the object identity of those
    segments in the keystome frame).
    
    Saves as a pickled DataFrame, so no need to override any methods.
    """
    _name = 'colorization_keystone_info'

class ColorizationCuratedNum2Name(CalculationHandlerWithoutDb):
    """Information about curated objects
    
    This defines the mapping between object labels and whisker names.
    Only the whiskers that were curated are included, so not whiskers
    that were impossible to do (or not worth doing) by eye.
    
    It is stored as a simple CSV file (with a space separator): first
    object id, then whisker name.
    """
    _name = 'colorization_curated_num2name'
    
    # Override because it's a CSV file
    def save_data(self, data):
        """Saves curated_num2name as space-separated CSV.
        
        data : pandas Series
            index: object id (integer)
            values: whisker name (string)
        
        Only manually curated whiskers are included here.
        
        Returns: string, full path to written file
        """
        filename = self.new_path_full
        
        # Save
        data.to_csv(filename, sep=' ')

        # This should now work
        return self.get_path
    
    # Override because it's a CSV file
    def load_data(self):
        """Read curated_num2name
        
        This is stored as a CSV file.
        
        Returns: pandas.Series
            index: object id (integer)
            values: whisker name (string)
        """
        filename = self.get_path
        data = pandas.read_table(filename, sep=' ', header=None, 
            names=['object', 'whisker'])
        
        data = data.set_index('object')['whisker']
        
        return data   

class ColorizationCurated(CalculationHandlerWithoutDb):
    """Curated object labels"""
    _name = 'colorization_curated'
    
class ColorizationPredictions(CalculationHandlerWithoutDb):
    """Curated object labels"""
    _name = 'colorization_predictions'

class ColorizationRepairedResults(CalculationHandlerWithoutDb):
    """Curated object labels"""
    _name = 'colorization_repaired_results'

class ColorizationHeldoutResults(CalculationHandlerWithoutDb):
    """Curated object labels"""
    _name = 'colorization_heldout_results'

class CWE_with_kappa(CalculationHandlerWithoutDb):
    """Copy of cwe with kappa added"""
    _name = 'cwe_with_kappa'

class WhiskerJoints(CalculationHandlerWithoutDb):
    """DataFrame of labeled joints"""
    _name = 'joints'

class FrameMeanLuminances(CalculationHandlerWithoutDb):
    """The mean luminance of each frame"""
    _name = 'lums'

    def calculate(self, force=False, verbose=True, stop_after_frame=None):
        """Calculate mean luminance of each frame
        
        stop_after_frame : for debugging
        verbose : if True, prints out frame numbers after each chunk
        """
        # Return if force=False and the data exists
        if not force:
            # Check if data available
            data_available = True
            try:
                self.get_path
            except IOError:
                data_available = False
            
            # Return if it is
            if data_available:
                return

        # Check that monitor video is set
        try:
            video_file = self.video_session.data.monitor_video.get_path
        except IOError:
            raise IOError("cannot calculate luminances without monitor video")
        
        # Calculate
        lums = my.video.process_chunks_of_video(video_file, 
            n_frames=stop_after_frame, verbose=verbose)
        
        # DataFrame it
        lumsdf = pandas.Series(lums, 
            index=pandas.Index(range(len(lums)), name='frame'),
            name='luminance')
        
        # Save
        self.save_data(lumsdf)
        
        # Error check that we got the right number of frames
        # Do this after saving to ease debugging
        if stop_after_frame is None:
            video_duration = my.video.get_video_duration2(video_file)
            video_fps = my.video.get_video_params(video_file)[2]
            n_frames_in_video = int(np.rint(video_duration * video_fps))
            assert len(lums) == n_frames_in_video
        else:
            assert len(lums) == stop_after_frame        