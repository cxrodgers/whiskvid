import os
import pandas
from base import *
from WhiskersTableHandler import WhiskersTableHandler

class TacHandler(CalculationHandler):
    _db_field_path = 'tac_filename'
    _name = 'tac'
    
    def calculate(self, **kwargs):
        pass
    
    def set_manual_params_if_needed(self, **kwargs):
        pass

class AllEdgesHandler(CalculationHandler):
    """Handler for all_edges. Uses numpy.load"""
    _db_field_path = 'all_edges_filename'
    _name = 'all_edges'
    
    def load_data(self):
        filename = self.get_path
        try:
            data = np.load(filename)
        except IOError:
            raise IOError("no all_edges found at %s" % filename)
        return data

class EdgeSummaryHandler(CalculationHandler):
    _db_field_path = 'edge_summary_filename'
    _name = 'edge_summary'

class MonitorVideoHandler(CalculationHandler):
    """Handler for a monitor video generated by WhiskiWrap trace.
    
    Unlike other handlers, this data is a side effect of trace, so
    this would be set by another calculation.
    
    load_data is not implemented
    """
    _db_field_path = 'monitor_video'
    _name = 'monitor_video'
    
    # Override because it's not just _name
    @property
    def new_path(self):
        return self.video_session.name + '.mkv'

class ClusteredTacHandler(CalculationHandler):
    """Tac after clustering"""
    _db_field_path = 'clustered_tac_filename'
    _name = 'clustered_tac'

class ColorizedWhiskerEndsHandler(CalculationHandler):
    """Whisker ends after colorizing"""
    _db_field_path = 'colorized_whisker_ends_filename'
    _name = 'colorized_whisker_ends'
    
class ContactsSummaryHandler(CalculationHandler):
    """Contacts summmary"""
    _db_field_path = 'contacts_summary_filename'
    _name = 'contacts_summary'

class ColorizedContactsSummaryHandler(CalculationHandler):
    """Colorized contacts summmary"""
    _db_field_path = 'colorized_contacts_summary_filename'
    _name = 'colorized_contacts_summary'
    
    def calculate(self, force=False, save=True):
        """Colorize the contacts in cs using colorized_whisker_ends
        
        See colorize_contacts_summary_nodb for algorithm. This loads
        data from disk and stores result.
        
        Returns : colorized_contacts_summary
        """
        # Return if force=False and we can load the data
        if not force:
            failed_to_read_data = False
            try:
                data = self.load_data()
            except (FieldNotSetError, FileDoesNotExistError):
                # Failed to read, probably not calculated
                failed_to_read_data = True
            
            # Return data if we were able to load it
            if not failed_to_read_data:
                return data
            
            # Warn if we couldn't load data but we were supposed to be able to
            if not self.field_is_null:
                print (("warning: %s was set " % self._db_field_name) + 
                    "but could not load data, recalculating" 
                )
        
        ## Begin handler-specific stuff
        # Load necessary data
        ctac = self.video_session.data.clustered_tac.load_data()
        cs = self.video_session.data.contacts_summary.load_data()
        cwe = self.video_session.data.colorized_whisker_ends.load_data()
        
        # Calculate
        ccs = colorize_contacts_summary_nodb(ctac, cs, cwe)
        ## End handler-specific stuff
        
        # Store
        if save:
            self.save_data(ccs)
        
        return ccs

def colorize_contacts_summary_nodb(ctac, cs, cwe):
    """Colorize the contacts in cs using colorized_whisker_ends

    We first load the colorized_whisker_ends, contacts_summary,
    and clustered_tac. We colorize each tac, and then propagate this
    color to cs. For the last step, we take the most common color of
    tac within that clustered_tac. 

    Returns: colorized_contacts_summary
        This is contacts_summary with another column for color
    """
    # Copy so we can assign a new column
    cs = cs.copy()
    
    # Assign the color from cwe to clustered_tac
    # ctac shares an index with cwe
    ctac['color'] = cwe.loc[ctac.index, 'color_group']

    # Group the ctac by 'group' (index into cs)
    # Choose the most common color within that gruop
    grouped_ctac = ctac.groupby('group')['color']

    # Choose the color for each group
    def choose_color_group(color_series):
        """Identify the most common color in color_series
        
        color_series : Series where the values are colors
        
        Returns: dict
            n_cg : number of unique colors
            nnz_cg : number of non-zero unique colors
            cg : most common color
        """
        vc = color_series.value_counts()
        return {
            'n_cg': len(vc), 
            'cg': vc.idxmax(), 
            'nnz_cg': len(vc.drop(0, errors='ignore'))
        }
    chosen_colors = grouped_ctac.apply(choose_color_group).unstack()    
    
    # Determine how well-assigned the colors were
    print ("Of %d, %d were unique, %d were unique after dropping 0" % (
        len(chosen_colors), 
        (chosen_colors.n_cg == 1).sum(), 
        (chosen_colors.nnz_cg == 1).sum(),) +
        " and %d were assigned 0" % (
        chosen_colors.cg == 0).sum()
    )    
    
    # Use the fac that ctac.group is the index of cs
    cs['color'] = chosen_colors['cg']     
    
    return cs

## Handlers for data that haven't been incorporated into the database yet
# Need to do this, so that we can easily check which have been generated
# For now we hard-code the path
class CalculationHandlerWithoutDb(CalculationHandler):
    """Overload for data not in db
    
    """
    @property
    def get_path(self):
        """Assumes self.new_path is the name, checks if it exists, returns

        Raises IOError if the file doesn't exist
        """
        full_filename = os.path.join(self.video_session.session_path,
            self.new_path)
        if not os.path.exists(full_filename):
            raise IOError("file does not exist: %s" % full_filename)
        return full_filename
    
    def set_path(self):
        raise NotImplementedError(
            "set_path not available because this calculation is not in the db")

class MaskedWhiskerEndsHandler(CalculationHandlerWithoutDb):
    """Whisker ends after follicle mask"""
    _name = 'masked_whisker_ends'
    
    # Override because it's not just _name
    @property
    def new_path(self):
        return 'mwe'

class VideoTrackedWhiskersHandler(CalculationHandlerWithoutDb):
    """Tracked whiskers video. Side effect of trace"""
    _name = 'video_tracked_whiskers'

    # Override because it's not just _name
    @property
    def new_path(self):
        return self.video_session.name + '.tracked_whiskers.mkv'
    
class VideoColorizedWhiskersHandler(CalculationHandlerWithoutDb):
    """Tracked whiskers video. Side effect of colorizing"""
    _name = 'video_colorized_whiskers'
    
    # Override because it's not just _name
    @property
    def new_path(self):
        return self.video_session.name + '_colorized_video.mp4'

class NeuralPathJoiner(object):
    def __init__(self, neural_session, root_directory=None):
        # Figure out which root directory we're using
        if root_directory is None:
            # Try each root directory in turn
            for try_root_dir in neural_root_directory_search_list:
                self._root_directory = try_root_dir
                self._session_directory = os.path.join(self._root_directory,
                    neural_session._field_name)
                
                if os.path.exists(self._session_directory):
                    break
        else:
            # Use the requested root directory
            self._root_directory = try_root_dir
            self._session_directory = os.path.join(self._root_directory,
                neural_session._field_name)            
        
        # Ensure we found the session
        if not os.path.exists(self._session_directory):
            raise IOError("cannot find session directory at %s" %
                self._session_directory)
        
        self._neural_session = neural_session
        self._neural_session_name = neural_session.name
    
    @property
    def session(self):
        return self._session_directory
    
    @property
    def sort(self):
        return os.path.join(self._session_directory, 
            self._neural_session.sort_name)
    
    @property
    def kwik(self):
        return os.path.join(self.sort, self._neural_session._field_kwik_filename)

    @property
    def kwx(self):
        return os.path.join(self.sort, self._neural_session._field_kwx_filename)