import os
import pandas
from base import *
from WhiskersTableHandler import WhiskersTableHandler
from EdgesHandlers import AllEdgesHandler, EdgeSummaryHandler
from ColorizedWhiskerEnds import ColorizedWhiskerEndsHandler
from TacHandler import TacHandler, ClusteredTacHandler
from ContactsSummaryHandlers import (
    ContactsSummaryHandler, ColorizedContactsSummaryHandler)

# For making colorized video
import numpy as np
import tables
import whiskvid
import MCwatch.behavior
import WhiskiWrap

class MonitorVideoHandler(CalculationHandler):
    """Handler for a monitor video generated by WhiskiWrap trace.
    
    Unlike other handlers, this data is a side effect of trace, so
    this would be set by another calculation.
    
    load_data is not implemented
    """
    _db_field_path = 'monitor_video'
    _name = 'monitor_video'
    
    # Override because it's not just _name
    @property
    def new_path(self):
        return self.video_session.name + '.mkv'

## Handlers for data that haven't been incorporated into the database yet
# Need to do this, so that we can easily check which have been generated
# For now we hard-code the path
class CalculationHandlerWithoutDb(CalculationHandler):
    """Overload for data not in db
    
    """
    @property
    def get_path(self):
        """Assumes self.new_path is the name, checks if it exists, returns

        Raises IOError if the file doesn't exist
        """
        full_filename = os.path.join(self.video_session.session_path,
            self.new_path)
        if not os.path.exists(full_filename):
            raise IOError("file does not exist: %s" % full_filename)
        return full_filename
    
    def set_path(self):
        raise NotImplementedError(
            "set_path not available because this calculation is not in the db")

class MaskedWhiskerEndsHandler(CalculationHandlerWithoutDb):
    """Whisker ends after follicle mask
    
    I don't think this is necessary anymore. WhiskersTableHandler loads
    and masks.
    """
    _name = 'masked_whisker_ends'
    
    # Override because it's not just _name
    @property
    def new_path(self):
        return 'mwe'

class VideoTrackedWhiskersHandler(CalculationHandlerWithoutDb):
    """Tracked whiskers video. Side effect of trace"""
    _name = 'video_tracked_whiskers'

    # Override because it's not just _name
    @property
    def new_path(self):
        return self.video_session.name + '.tracked_whiskers.mkv'

class VideoColorizedWhiskersHandler(CalculationHandlerWithoutDb):
    """Tracked whiskers video. Side effect of colorizing"""
    _name = 'video_colorized_whiskers'

    # The fields that are required before calculate can run
    _required_fields_for_calculate = (
        'monitor_video', 'all_edges_filename',
        'colorized_whisker_ends_filename',
    )

    # Override because it's not just _name
    @property
    def new_path(self):
        return self.video_session.name + '_colorized_video.mp4'

    def calculate(self, force=False):
        # Where to put result
        output_filename = self.new_path_full

        # Return if force=False and we can load the data
        if not force and os.path.exists(output_filename):
            return

        # We are going to try to calculate
        # Ensure required fields are set
        if not self._check_if_required_fields_for_calculate_set():
            raise RequiredFieldsNotSetError(self)

        # Get clustered tac and contacts summary
        clustered_tac = self.video_session.data.clustered_tac.load_data()
        contacts_summary = self.video_session.data.contacts_summary.load_data()
        cwe = self.video_session.data.colorized_whisker_ends.load_data()

        # Get edges
        edge_summary = self.video_session.data.edge_summary.load_data()
        typical_edges_hist2d = whiskvid.normalize_edge_summary(edge_summary)

        # Get trial matrix
        bsession = self.video_session.bsession_name
        tm = MCwatch.behavior.db.get_trial_matrix(bsession, add_rwin_and_choice_times=True)

        # Get the frame at which the chocie was made
        choice_vtime = np.polyval(self.video_session.fit_b2v, tm['choice_time'])
        tm['choice_frame'] = np.rint(choice_vtime * 30)    

        # This isn't working because relative_t is missing
        #~ ## Choose the frame triggers
        #~ # Count the number of contacts per trial for selecting the ones to plot
        #~ ct2 = clustered_tac[
            #~ (clustered_tac.frame < 200e3) &
            #~ (clustered_tac.relative_t > -1.5) & 
            #~ (clustered_tac.relative_t < .25)
            #~ ]
        #~ group_trial = ct2.groupby('group')['trial'].apply(lambda ser: ser.unique()[0])
        #~ cpt = group_trial.value_counts().sort_values()

        #~ # Interdigitate L and R trials
        #~ l_trials_to_plot = cpt[cpt.index.isin(tm[tm.rewside == 'left'].index)]
        #~ r_trials_to_plot = cpt[cpt.index.isin(tm[tm.rewside == 'right'].index)]
        #~ trials_to_plot = np.ravel([
            #~ l_trials_to_plot.index[:-5:-1].values, 
            #~ r_trials_to_plot.index[:-5:-1].values,
            #~ ], order='F')

        #~ # Get the frame triggers
        #~ frame_triggers = tm.loc[trials_to_plot, 'choice_frame'].dropna().values
        #~ frame_triggers = np.sort(frame_triggers)

        # choose by trial number
        frame_triggers = tm['choice_frame'].dropna()
        frame_triggers = frame_triggers[frame_triggers > 1000]
        frame_triggers = frame_triggers.values[::20]

        def get_extra_text(frame_number):
            trial_idx = np.searchsorted(tm.choice_frame + 400, [frame_number])[0]
            return '%d-%d-%s-%0.3f' % (
                tm.loc[trial_idx, 'servo_pos'],
                tm.loc[trial_idx, 'stepper_pos'],
                tm.loc[trial_idx, 'outcome'],
                tm.loc[trial_idx, 'rt'],
            )

        ## Monitor video
        input_frame_offset = frame_triggers[0] - 200
        input_reader = WhiskiWrap.FFmpegReader(
            self.video_session.data.monitor_video.get_path,
            start_frame_number=input_frame_offset
        )

        with tables.open_file(self.video_session.data.whiskers.get_path) as wfh:
            whiskvid.output_video.write_video_with_overlays(
                output_filename=output_filename,
                input_reader=input_reader, 
                input_width=input_reader.frame_width, 
                input_height=input_reader.frame_height, 
                frame_triggers=frame_triggers, 
                trigger_dstart=-200, trigger_dstop=50,
                d_temporal=1, d_spatial=1,
                whiskers_table=cwe,
                whiskers_file_handle=wfh,
                contacts_table=clustered_tac,
                edges_filename=self.video_session.data.all_edges.get_path,
                typical_edges_hist2d=typical_edges_hist2d,
                input_frame_offset=input_frame_offset,
                post_contact_linger=5,
                contact_colors=whiskvid.WHISKER_COLOR_ORDER_W,
                get_extra_text=get_extra_text,
                )