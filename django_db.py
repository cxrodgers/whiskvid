"""Module for interacting with django whisker video database."""

import os
import pandas
import numpy as np
import django
import sys
import whisk_video

# Search in the following order for the session
root_directory_search_list = [
    '/mnt/fast/data/whisker/processed',
    '/home/chris/whisker_video',
    os.path.expanduser('~/mnt/nas2_home/whisker/processed'),
]
neural_root_directory_search_list = [
    '/mnt/fast/data/neural',
    '/home/chris/data',
    os.path.expanduser('~/mnt/nas2_home/neural'),
]


class CalculationHandler(object):
    """Generic object for handling results of a calculation
    
    Derived objects must set these attributes:
        _name
        _db_field_path
    """
    def __init__(self, video_session):
        """Initalize a new handler for this video session"""
        self.video_session = video_session
        
    @property
    def get_path(self):
        """Full path to file using session directory and database field
        
        Raises ValueError if the field is not set
        Raises IOError if the field is set but the file does not exist
        
        Returns: full path to file
        """
        # Refresh db
        # This may not really be necessary if it causes slow downs
        self.video_session._django_object.refresh_from_db()
        
        # Get the filename from the db
        short_filename = getattr(self.video_session._django_object,
            self._db_field_path)
        
        # Test if null
        if short_filename is None or short_filename == '':
            raise ValueError("%s is not set in db for %s" % (
                self._db_field_path, str(self.video_session)))
            return None
        
        # Raise exception if file doesn't exist?
        full_filename = os.path.join(
            self.video_session.session_path,
            short_filename,
        )
        if not os.path.exists(full_filename):
            raise IOError("file does not exist: %s" % full_filename)
        
        # Return
        return full_filename
    
    @property
    def new_path(self):
        """Generate a new filename
        
        This will not be a full path, but a short filename, suitable
        for setting the database with.
        """
        return self._name

    def set_path(self, new_path=None):
        """Set file in database
        
        By default it is set to the default value given by self.new_path
        If another path is desired, specify `new_path`. It should be a
        short filename, not a full path.
        
        Triggers a database save.
        
        Returns: new_path
        """
        if new_path is None:
            new_path = self.new_path
        
        setattr(self.video_session._django_object, self._db_field_path, 
            new_path)
        self.video_session._django_object.save()
        
        return new_path

    def load_data(self):
        """Read data or raise IOError"""
        filename = self.get_path
        try:
            data = pandas.read_pickle(filename)
        except (KeyError, IOError):
            # KeyError sometimes raise when unpickling a non-pickle
            raise IOError("cannot read pickle at %s" % filename)
        return data        

    def calculate(self, **kwargs):
        pass
    
    def set_manual_params_if_needed(self, **kwargs):
        pass

class TacHandler(CalculationHandler):
    _db_field_path = 'tac_filename'
    _name = 'tac'
    
    def calculate(self, **kwargs):
        pass
    
    def set_manual_params_if_needed(self, **kwargs):
        pass

class AllEdgesHandler(CalculationHandler):
    """Handler for all_edges. Uses numpy.load"""
    _db_field_path = 'all_edges_filename'
    _name = 'all_edges'
    
    def load_data(self):
        filename = self.get_path
        try:
            data = np.load(filename)
        except IOError:
            raise IOError("no all_edges found at %s" % filename)
        return data

class EdgeSummaryHandler(CalculationHandler):
    _db_field_path = 'edge_summary_filename'
    _name = 'edge_summary'

class MonitorVideoHandler(CalculationHandler):
    """Handler for a monitor video generated by WhiskiWrap trace.
    
    Unlike other handlers, this data is a side effect of trace, so
    this would be set by another calculation.
    
    load_data is not implemented
    """
    _db_field_path = 'monitor_video'
    _name = 'monitor_video'
    
    # Override because it's not just _name
    @property
    def new_path(self):
        return self.video_session.name + '.mkv'

## Handlers for data that haven't been incorporated into the database yet
# Need to do this, so that we can easily check which have been generated
# For now we hard-code the path
class CalculationHandlerWithoutDb(CalculationHandler):
    """Overload for data not in db
    
    """
    @property
    def get_path(self):
        """Assumes self.new_path is the name, checks if it exists, returns

        Raises IOError if the file doesn't exist
        """
        full_filename = os.path.join(self.video_session.session_path,
            self.new_path)
        if not os.path.exists(full_filename):
            raise IOError("file does not exist: %s" % full_filename)
        return full_filename
    
    def set_path(self):
        raise NotImplementedError(
            "set_path not available because this calculation is not in the db")
    
class MaskedWhiskerEndsHandler(CalculationHandlerWithoutDb):
    """Whisker ends after follicle mask"""
    _name = 'masked_whisker_ends'
    
    # Override because it's not just _name
    @property
    def new_path(self):
        return 'mwe'

class ClusteredTacHandler(CalculationHandlerWithoutDb):
    """Tac after clustering"""
    _name = 'clustered_tac'

class ColorizedWhiskerEndsHandler(CalculationHandlerWithoutDb):
    """Whisker ends after colorizing"""
    _name = 'colorized_whisker_ends'
    
class ContactsSummaryHandler(CalculationHandlerWithoutDb):
    """Contacts summmary"""
    _name = 'contacts_summary'

class VideoTrackedWhiskersHandler(CalculationHandlerWithoutDb):
    """Tracked whiskers video. Side effect of trace"""
    _name = 'video_tracked_whiskers'

    # Override because it's not just _name
    @property
    def new_path(self):
        return self.video_session.name + '.tracked_whiskers.mkv'
    
class VideoColorizedWhiskersHandler(CalculationHandlerWithoutDb):
    """Tracked whiskers video. Side effect of colorizing"""
    _name = 'video_colorized_whiskers'
    
    # Override because it's not just _name
    @property
    def new_path(self):
        return self.video_session.name + '_colorized_video.mp4'

class NeuralPathJoiner(object):
    def __init__(self, neural_session, root_directory=None):
        # Figure out which root directory we're using
        if root_directory is None:
            # Try each root directory in turn
            for try_root_dir in neural_root_directory_search_list:
                self._root_directory = try_root_dir
                self._session_directory = os.path.join(self._root_directory,
                    neural_session._field_name)
                
                if os.path.exists(self._session_directory):
                    break
        else:
            # Use the requested root directory
            self._root_directory = try_root_dir
            self._session_directory = os.path.join(self._root_directory,
                neural_session._field_name)            
        
        # Ensure we found the session
        if not os.path.exists(self._session_directory):
            raise IOError("cannot find session directory at %s" %
                self._session_directory)
        
        self._neural_session = neural_session
        self._neural_session_name = neural_session.name
    
    @property
    def session(self):
        return self._session_directory
    
    @property
    def sort(self):
        return os.path.join(self._session_directory, 
            self._neural_session.sort_name)
    
    @property
    def kwik(self):
        return os.path.join(self.sort, self._neural_session._field_kwik_filename)

    @property
    def kwx(self):
        return os.path.join(self.sort, self._neural_session._field_kwx_filename)

class HandlerHolder(object):
    pass

class VideoSession(object):
    """Interface to all of the data about a video session.
    
    It is initialized from a database object from whisk_video.models.
    """
    def __init__(self, django_object, forced_root_directory=None):
        """Initialize a new video session from database object
        
        forced_root_directory : force root to be in a certain location
            Otherwise the search tree is followed
        """
        # Store a reference to the django_object
        self._django_object = django_object

        # Set the session directory
        self._set_session_path(forced_root_directory)
        
        # Install the handlers
        self.data = HandlerHolder()
        for handler_class in [TacHandler, AllEdgesHandler, EdgeSummaryHandler,
            MonitorVideoHandler, ClusteredTacHandler, 
            ColorizedWhiskerEndsHandler,
            ContactsSummaryHandler, MaskedWhiskerEndsHandler, 
            VideoColorizedWhiskersHandler, VideoTrackedWhiskersHandler]:
            # Init the handler
            handler = handler_class(self)
            
            if hasattr(self.data, handler._name):
                raise ValueError("handler %s already installed" % handler._name)
            
            # Store
            setattr(self.data, handler._name, handler)

    ## Initializing shortcut
    @classmethod
    def from_name(self, name):
        """Query database for session name and initialize VideoSession"""
        # Load django object
        django_vsession = whisk_video.models.VideoSession.objects.filter(
            name=name).first()
        
        # Initialize object from that
        return VideoSession(django_vsession)

    ## Link to appropriate session directory
    def _set_session_path(self, forced_root_directory=None):
        """Find the appropriate session directory
        
        Tries each path in the search list. Usually this is just called
        once during initialization.
        """
        # Depends on if we are forcing a root directory
        if forced_root_directory is None:
            # Try each root directory in turn
            for try_root_dir in root_directory_search_list:
                # Try the next one
                self._root_directory = try_root_dir
                self._session_directory = os.path.join(self._root_directory,
                    self.name)
                
                # Found it, break
                if os.path.exists(self._session_directory):
                    break
        else:
            # Use the requested root directory
            self._root_directory = forced_root_directory
            self._session_directory = os.path.join(self._root_directory,
                video_session.name)      

        # Ensure we found the session
        if not os.path.exists(self._session_directory):
            raise IOError("cannot find session directory at %s" %
                self._session_directory)        
    
    @property
    def session_path(self):
        """Path to the directory containing all session files"""
        return self._session_directory

    ## Shortcut accessor methods to commonly used fields in django object
    # Other properties may be accessed like
    # vs._django_object.field_name
    @property
    def frame_height(self):
        return self._django_object.frame_height
    
    @property
    def frame_width(self):
        return self._django_object.frame_width

    @property
    def name(self):
        return self._django_object.name
    
    @property
    def frame_rate(self):
        return self._django_object.frame_rate
    
    # Other accessors that are not simple short cuts
    @property
    def bsession_name(self):
        return self._django_object.bsession.name
    
    @property
    def fit_b2v(self):
        return np.array([
            self._django_object.fit_b2v0,
            self._django_object.fit_b2v1,
        ])

    @property
    def fit_v2b(self):
        return np.array([
            self._django_object.fit_v2b0,
            self._django_object.fit_v2b1,
        ])

class NeuralSession(object):
    """Interface to all of the data about a neural session.
    
    It is initialized from a database object from neural_sessions.models.
    Each field is available as a hidden attribute beginning with "_field"
    
    The preferred way to access data stored on disk are as follows:
        get_path : filenames to data stored on disk
            Will return null ('') if no filename stored in database
        load_data : loading methods for data stored on disk
            Will raise IOError if fails to load
    """
    def __init__(self, django_object):
        # Copy values
        for field in django_object._meta.fields:
            setattr(self, '_field_' + field.name, 
                getattr(django_object, field.name))
        
        # Unhide simple properties
        simple_properties_l = ['name', 'sort_name',]
        for simple_property in simple_properties_l:
            try:
                value = getattr(self, '_field_' + simple_property)
            except AttributeError:
                continue
            setattr(self, simple_property, value)

        # _field_bsession is a django object, for now
        # at least extract the name
        try:
            self.bsession_name = self._field_bsession.name
        except AttributeError:
            self.bsession_name = None

        # PathJoiner (uses simple properties like name)
        self.get_path = NeuralPathJoiner(self)

    @property
    def fit_b2n(self):
        return np.array([
            self._field_fit_b2n0,
            self._field_fit_b2n1,
        ])

    @property
    def fit_n2b(self):
        return np.array([
            self._field_fit_n2b0,
            self._field_fit_n2b1,
        ])